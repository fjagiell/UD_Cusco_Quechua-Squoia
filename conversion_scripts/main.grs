% merging morphemes
package concatenate{
  rule mergens{
    pattern{
      V [];
      NS [upos=NS|NS_Num|NS_VS];
      V -> NS;
      V < NS; % V must directly preced NS in the sentence
    }
    commands{
      V.form = V.form + NS.form;
      V._MISC_FEATURES = V._MISC_FEATURES + NS._MISC_FEATURES;
      shift NS ==> V;
      del_node NS;
    }
  }

  rule mergens_advcl{
    pattern{
      V [upos=VERB];
      NS [upos=NS];
      adv: V -[1=advcl,2=ds|ss]-> NS;
      V < NS;
      O [];
      e: O -> V;
    }
    commands{
      del_edge e;
      add_edge adv: O -> V;
      V.form = V.form + NS.form;
      V._MISC_FEATURES = V._MISC_FEATURES + NS._MISC_FEATURES;
      shift_out NS ==> V;
      del_node NS;
    }
  }

  rule amb_nmod{
    pattern{
      Amb [upos=Amb];
      Root [xpos=Root|ADP];
      e: Root -[nmod]-> Amb;
    }
    commands{
      Root.form = Root.form + Amb.form;
      Root._MISC_FEATURES = Root._MISC_FEATURES + Amb._MISC_FEATURES;
      shift Amb ==> Root;
      del_node Amb;
      del_edge e;
    }
  }

  rule suffix{
    pattern{
      Root [];
      Suffix [xpos=SUFFIX];
      Root -> Suffix;
      Root < Suffix;
    }
    commands{
      Root.form = Root.form + Suffix.form;
      Root._MISC_FEATURES = Root._MISC_FEATURES + Suffix._MISC_FEATURES;
      shift Suffix ==> Root;
      del_node Suffix;
    }
  }

  rule asp_amb{
    pattern{
      Asp [upos=Asp_Amb|Asp];
      V [upos=VERB|AUX];
      V -[nmod]-> Asp;
      V < Asp;
    }
    commands{
      V.form = V.form + Asp.form;
      V._MISC_FEATURES = V._MISC_FEATURES + Asp._MISC_FEATURES;
      shift Asp ==> V;
      del_node Asp;
    }
  }

  rule sarg{
    pattern{
      Root [xpos=Root, upos=NOUN];
      ND [xpos=NDeriv];
      ND -[s.arg]-> Root;
    }commands{
      ND.form = Root.form + ND.form;
      ND._MISC_FEATURES = ND._MISC_FEATURES + Root._MISC_FEATURES;
      ND.upos = Root.upos;
      shift Root ==> ND;
      del_node Root;
    }
  }

  rule case{
    pattern{
      Root [xpos=Root|FLM];
      C [upos=Cas];
      C -[s.arg|poss.subj]-> Root;
      Root < C;
    }
    commands{
      Root.form = Root.form + C.form;
      Root._MISC_FEATURES = Root._MISC_FEATURES + C._MISC_FEATURES;
      shift C ==> Root;
      del_node C;
    }
  }

  rule case_cleanup{
    pattern{
      Root [];
      C [upos=Cas];
      e: Root -> C;
    }
    commands{
      C.upos = ADP;
      del_edge e;
      add_edge Root -[case]-> C;
    }
  }

  rule vderiv{
    pattern{
      Root [xpos=Root|Root_NDeriv_VS|Root_VS_VDeriv];
      Vderiv [xpos=VDeriv];
      Root -> Vderiv;
      Root < Vderiv;
    }
    commands{
      Root.form = Root.form + Vderiv.form;
      Root._MISC_FEATURES = Root._MISC_FEATURES + Vderiv._MISC_FEATURES;
      shift Vderiv ==> Root;
      del_node Vderiv;
    }
  }
}


% edge rewriting
package rewrite{
    rule amb{
    pattern{
      Amb [upos=Amb];
      Root [xpos=Root];
      e: Root -[ev|topic|epst]-> Amb;
    }
    commands{
      Amb.upos = PART;
      del_edge e;
      add_edge Root -[discourse]-> Amb;
    }
  }

  rule amb_taq{
    pattern{
      Amb [upos=Amb, form="-taq"];
      Root [xpos=Root];
      e: Root -[s.co]-> Amb;
    }
    commands{
      Amb.upos = PART;
      del_edge e;
      add_edge Root -[discourse]-> Amb;
    }
  }

  rule nsubj{
    pattern{
      N [upos=NOUN];
      Root [upos=VERB];
      Root -[poss.subj|subj]-> N;
    }
    commands{
      del_edge Root -[poss.subj]-> N;
      del_edge Root -[subj]-> N;
      add_edge Root -[nsubj]-> N;
    }
  }

  rule csubj{
    pattern{
      V [xpos=Root,upos=VERB];
      Root [upos=VERB];
      V -[poss.subj]-> Root;
    }
    commands{
      del_edge V -[poss.subj]-> Root;
      add_edge V -[csubj]-> Root;
    }
  }

  rule nsubj_advcl{
    pattern{
      V [upos=VERB];
      N [upos=NOUN];
      O[];
      O -[1=advcl]-> V;
      e: V -[subj]-> N;
    }commands{
      del_edge e;
      add_edge V -[nsubj]-> N;
    }
  }

  rule tmp{
    pattern{
      N [upos=NOUN];
      Other [];
      Other -[tmp]-> N;
    }
    commands{
      del_edge Other -[tmp]-> N;
      add_edge Other -[obl]-> N;
    }
  }

  rule ser{
    pattern{
      Pred [];
      Ser [upos=VERB|X|AUX];
      Zero [!upos];
      pred_edge: Ser -[pred]-> Pred;
      root_edge: Zero -[cop]-> Ser;
    }
    commands{
      del_edge pred_edge;
      shift Ser ==> Pred;
      del_edge root_edge;
      Ser.upos = AUX;
      add_edge Zero -[root]-> Pred;
      add_edge Pred -[cop]-> Ser;

    }
  }

  rule pred{
    pattern{
      Root [upos=VERB];
      V [upos=VERB];
      Root -[pred]-> V;
    }
    commands{
      del_edge Root -[pred]-> V;
      add_edge Root -[dep]-> V;
    }
  }

  rule det{
    pattern{
      Det [upos=DET];
      N [upos=NOUN];
      N -[p.arg]-> Det;
    }
    commands{
      del_edge N -[p.arg]-> Det;
      add_edge N -[det]-> Det;
    }
  }

  rule nummod{
    pattern{
      Q [upos=NUM];
      N [upos = NOUN];
      N -[qnt]->Q;
    }
    commands{
      del_edge  N -[qnt]-> Q;
      add_edge N -[nummod]-> Q;
    }
  }

  rule advcl{
    pattern{
      V [upos=VERB];
      Root [upos=VERB];
      Punct [upos=PUNCT];
      Punct << V;
      Root -[nmod]-> V;
    }commands{
      del_edge Root -[nmod]-> V;
      add_edge Root -[advcl]-> V;
    }
  }

  rule obl{
    pattern{
      N [upos=NOUN|VERB|NUM];
      V [upos=VERB];
      V -[nmod]-> N;
    }
    commands{
      del_edge V -[nmod]-> N;
      add_edge V -[obl]-> N;
    }
  }

  rule obl2{
    pattern{
      N [upos=NOUN];
      V [upos=VERB];
      V -[adv]-> N;
    }
    commands{
      del_edge V -[adv]-> N;
      add_edge V -[obl]-> N;
    }
  }

  rule punct1{
    pattern{
      P1 [upos=PUNCT];
      P2 [upos=PUNCT];
      Other [];
      Other2 [];
      P1 < Other;
      Other << P2;
      P2 < Other2;
      Any [];
      Any -[punct]-> P1;
      Any -[punct]-> P2;
    }
    commands{
    del_edge Any -[punct]-> P1;
    del_edge Any -[punct]-> P2;
    add_edge Other -[punct]-> P1;
    add_edge Other -[punct]-> P2;
    }
  }

  rule neg{
    pattern{
      Neg [upos=NEG];
      Other [];
      Other -[neg]-> Neg;
    }
    commands{
      del_edge Other -[neg]-> Neg;
      add_edge Other -[advmod]-> Neg;
      Neg.upos = ADV;
    }
  }

  rule sntc{
    pattern{
      Zero [!upos];
      R [];
      e:Zero -[sntc]-> R;
    }
    commands{
      del_edge e;
      add_edge Zero -[root]-> R;
    }
  }

  rule subj{
    pattern{
      Zero [!upos];
      R [];
      Zero -[root]-> R;
      Subj [upos=NOUN|NUM];
      e: R -[subj]-> Subj;
    }
    commands{
      del_edge e;
      add_edge R -[nsubj]-> Subj;
    }
  }

  rule cleanup_amb1{
    pattern{
      Amb [upos=Amb];
      O[];
      e: O -> Amb;
    }
    commands{
      Amb.upos = PART;
      del_edge e;
      add_edge O -[discourse]-> Amb;
    }
  }

  rule punct{
    pattern{
      Zero [!upos];
      Punct [upos=PUNCT];
      Root [];
      Zero -[root]-> Root;
      e: Zero -[punct]-> Punct;
    }
    commands{
      del_edge e;
      add_edge Root -[punct]-> Punct;
    }
  }

  rule poss_subj{
    pattern{
      Zero [!pos];
      Subj [upos=NOUN];
      V [upos=VERB];
      O[];
      Zero -[root]-> O;
      V -[poss.subj]-> Subj;
    }
    commands{
      del_edge  V -[poss.subj]-> Subj;
      add_edge V -[csubj]-> Subj;
    }
  }

  rule nsubj2{
    pattern{
      N [upos=NOUN];
      ADV [upos=VERB|ADV];
      Zero [!upos];
      O[];
      Zero -[root]-> O;
      O -[advcl]-> ADV;
      e: ADV -[nsubj]-> N;
    }
    commands{
      del_edge e;
      add_edge ADV -[csubj]-> N
    }
  }

  rule nummod{
    pattern{
      Num [upos=NUM];
      Noun [upos=NOUN];
      e: Noun -[nmod|mod|case]-> Num;
    }
    commands{
      del_edge e;
      add_edge Noun -[nummod]-> Num;
    }
  }

  rule icha{
    pattern{
      Icha [form=icha|Icha];
      First [];
      Second [];
      e1: Second -[linker]-> Icha;
    }commands{
      del_edge e1;
      add_edge Second -[conj]-> Icha;
      Icha.upos = CCONJ;
    }
  }

  rule root1{
    pattern{
      Root [upos=Root];
      Det [upos=DET];
      V [upos=VERB|AUX];
      V -> Root;
      e: Root -[det]-> Det;
    }commands{
      Root.upos = NOUN;
    }
  }

}

strat concatenate_onf {Seq ( Onf(concatenate.vderiv),
                        Onf(concatenate.asp_amb),
                        Onf(concatenate.mergens),
                        Onf(concatenate.mergens_advcl),
                        Onf(concatenate.amb_nmod),
                        Onf(concatenate.asp_amb),
                        Onf(concatenate.sarg),
                        Onf(concatenate.suffix),
                        Onf(concatenate.case),
                        Onf(concatenate.case_cleanup),
                        Onf(concatenate.mergens),
                        Onf(concatenate.suffix)
                    )
                }

strat rewrite_onf   { Seq ( Onf(rewrite.icha),
                            Onf(rewrite.amb),
                            Onf(rewrite.amb_taq),
                            Onf(rewrite.nsubj),
                            Onf(rewrite.csubj),
                            %Onf(rewrite.csubj_advcl),
                            Onf(rewrite.tmp),
                            Onf(rewrite.ser),
                            Onf(rewrite.det),
                            Onf(rewrite.nummod),
                            Onf(rewrite.advcl),
                            Onf(rewrite.obl),
                            Onf(rewrite.obl2),
                            Onf(rewrite.punct1),
                            Onf(rewrite.neg),
                            Onf(rewrite.sntc),
                            Onf(rewrite.cleanup_amb1),
                            Onf(rewrite.nsubj2),
                            Onf(rewrite.poss_subj),
                            Onf(rewrite.nsubj2),
                             Onf(rewrite.punct)
                        )
                    }

strat main {Seq (concatenate_onf, rewrite_onf)}
