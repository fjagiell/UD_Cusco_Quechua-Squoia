% merging morphemes
package concatenate{
  rule mergens{
    pattern{
      V [upos=VERB|NOUN];
      NS [upos=NS];
      V -[ns]-> NS;
      V < NS;
    }
    commands{
      V.form = V.form + NS.form;
      V._MISC_FEATURES = V._MISC_FEATURES + NS._MISC_FEATURES;
      shift NS ==> V;
      del_node NS;
    }
  }

  rule amb_nmod{
    pattern{
      Amb [upos=Amb];
      Root [xpos=Root];
      e: Root -[nmod]-> Amb;
    }
    commands{
      Root.form = Root.form + Amb.form;
      Root._MISC_FEATURES = Root._MISC_FEATURES + Amb._MISC_FEATURES;
      shift Amb ==> Root;
      del_node Amb;
    }
  }

  rule ds{
    pattern{
      NS [upos=NS, DS];
      V [upos=VERB];
      e: V -[ns]-> NS;
    }
    commands{
      V.form = V.form + NS.form;
      V._MISC_FEATURES = V._MISC_FEATURES + NS._MISC_FEATURES;
      shift NS ==> V;
      del_node NS;
    }
  }

  rule suffix{
    pattern{
      Root [xpos=Root];
      Suffix [xpos=SUFFIX];
      Root -[s.poss.subj|poss.subj|s.subj|s.poss]-> Suffix;
      Root < Suffix;
    }
    commands{
      Root.form = Root.form + Suffix.form;
      Root._MISC_FEATURES = Root._MISC_FEATURES + Suffix._MISC_FEATURES;
      shift Suffix ==> Root;
      del_node Suffix;
    }
  }

  rule asp_amb{
    pattern{
      Asp [upos=Asp_Amb];
      V [upos=VERB, xpos=Root];
      V -[nmod]-> Asp;
      V < Asp;
    }
    commands{
      V.form = V.form + Asp.form;
      V._MISC_FEATURES = V._MISC_FEATURES + Asp._MISC_FEATURES;
      shift Asp ==> V;
      del_node Asp;
    }
  }

  rule sarg{
    pattern{
      Root [xpos=Root, upos=NOUN];
      ND [upos=NDeriv];
      ND -[s.arg]-> Root;
    }commands{
      ND.form = Root.form + ND.form;
      ND._MISC_FEATURES = ND._MISC_FEATURES + Root._MISC_FEATURES;
      ND.upos = Root.upos;
      shift Root ==> ND;
      del_node Root;
    }
  }

  rule case{
    pattern{
      Root [xpos=Root];
      C [upos=Cas];
      C -[s.arg|poss.subj]-> Root;
      Root < C;
    }
    commands{
      Root.form = Root.form + C.form;
      Root._MISC_FEATURES = Root._MISC_FEATURES + C._MISC_FEATURES;
      Root.Case = C.Case;
      shift C ==> Root;
      del_node C;
    }
  }

  rule case_cleanup{
    pattern{
      Root [xpos=Root];
      C [upos=Cas];
      e: Root -[s.co|s.arg]-> C;
      Root << C;
    }
    commands{
      C.upos = ADP;
      del_edge e;
      add_edge Root -[case]-> C;
    }
  }

  rule vderiv{
    pattern{
      Root [xpos=Root];
      Vderiv [xpos=VDeriv];
      Root -> Vderiv;
    }
    commands{
      Root.form = Root.form + Vderiv.form;
      Root._MISC_FEATURES = Root._MISC_FEATURES + Vderiv._MISC_FEATURES;
      shift Vderiv ==> Root;
      del_node Vderiv;
    }
  }
}


% edge rewriting
package rewrite{
    rule amb{
    pattern{
      Amb [upos=Amb];
      Root [xpos=Root];
      e: Root -[ev|topic|epst]-> Amb;
    }
    commands{
      Amb.upos = PART;
      del_edge e;
      add_edge Root -[discourse]-> Amb;
    }
  }

  rule amb_taq{
    pattern{
      Amb [upos=Amb, form="-taq"];
      Root [xpos=Root];
      e: Root -[s.co]-> Amb;
    }
    commands{
      Amb.upos = PART;
      del_edge e;
      add_edge Root -[discourse]-> Amb;
    }
  }

  rule nsubj{
    pattern{
      N [upos=NOUN];
      Root [upos=VERB];
      Root -[poss.subj|subj]-> N;
    }
    commands{
      del_edge Root -[poss.subj]-> N;
      del_edge Root -[subj]-> N;
      add_edge Root -[nsubj]-> N;
    }
  }

  rule csubj{
    pattern{
      V [xpos=Root,upos=VERB];
      Root [upos=VERB];
      V -[poss.subj]-> Root;
    }
    commands{
      del_edge V -[poss.subj]-> Root;
      add_edge V -[csubj]-> Root;
    }
  }

  rule tmp{
    pattern{
      N [upos=NOUN];
      Other [];
      Other -[tmp]-> N;
    }
    commands{
      del_edge Other -[tmp]-> N;
      add_edge Other -[obl]-> N;
    }
  }

  rule ser{
    pattern{
      Pred [upos=VERB];
      Ser [upos=VERB];
      Zero [!upos];
      pred_edge: Ser -[pred]-> Pred;
      root_edge: Zero -[ser]-> Ser;
    }
    commands{
      del_edge pred_edge;
      shift Ser ==> Pred;
      del_edge root_edge;
      add_edge Zero -[root]-> Pred;
      add_edge Pred -[cop]-> Ser;

    }
  }

  rule pred{
    pattern{
      Root [upos=VERB];
      V [upos=VERB];
      Root -[pred]-> V;
    }
    commands{
      del_edge Root -[pred]-> V;
      add_edge Root -[dep]-> V;
    }
  }

  rule det{
    pattern{
      Det [upos=DET];
      N [upos=NOUN];
      N -[p.arg]-> Det;
    }
    commands{
      del_edge N -[p.arg]-> Det;
      add_edge N -[det]-> Det;
    }
  }

  rule nummod{
    pattern{
      Q [upos=NUM];
      N [upos = NOUN];
      N -[qnt]->Q;
    }
    commands{
      del_edge  N -[qnt]-> Q;
      add_edge N -[nummod]-> Q;
    }
  }

  rule advcl{
    pattern{
      V [upos=VERB];
      Root [upos=VERB];
      Punct [upos=PUNCT];
      Punct << V;
      Root -[nmod]-> V;
    }commands{
      del_edge Root -[nmod]-> V;
      add_edge Root -[advcl]-> V;
    }
  }

  rule obl{
    pattern{
      N [upos=NOUN|VERB|NUM];
      V [upos=VERB];
      V -[nmod]-> N;
    }
    commands{
      del_edge V -[nmod]-> N;
      add_edge V -[obl]-> N;
    }
  }

  rule obl2{
    pattern{
      N [upos=NOUN];
      V [upos=VERB];
      V -[adv]-> N;
    }
    commands{
      del_edge V -[adv]-> N;
      add_edge V -[obl]-> N;
    }
  }

  rule punct1{
    pattern{
      P1 [upos=PUNCT];
      P2 [upos=PUNCT];
      Other [];
      Other2 [];
      P1 < Other;
      Other << P2;
      P2 < Other2;
      Any [];
      Any -[punct]-> P1;
      Any -[punct]-> P2;
    }
    commands{
    del_edge Any -[punct]-> P1;
    del_edge Any -[punct]-> P2;
    add_edge Other -[punct]-> P1;
    add_edge Other -[punct]-> P2;
    }
  }
}

strat concatenate_onf {Seq (  Onf(concatenate.vderiv),
                        Onf(concatenate.mergens),
                        Onf(concatenate.amb_nmod),
                        Onf(concatenate.ds),
                        Onf(concatenate.asp_amb),
                        Onf(concatenate.sarg),
                        Onf(concatenate.suffix),
                        Onf(concatenate.case),
                        Onf(concatenate.case_cleanup)
                    )
                }

strat rewrite_onf   { Seq ( Onf(rewrite.amb),
                            Onf(rewrite.amb_taq),
                            Onf(rewrite.nsubj),
                            Onf(rewrite.csubj),
                            Onf(rewrite.tmp),
                            Onf(rewrite.ser),
                            Onf(rewrite.det),
                            Onf(rewrite.nummod),
                            Onf(rewrite.advcl),
                            Onf(rewrite.obl),
                            Onf(rewrite.obl2),
                            Onf(rewrite.punct1)
                        )
                    }

strat main {Seq (concatenate_onf, rewrite_onf)}
